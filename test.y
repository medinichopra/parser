%{
 /* C Declarations and Definitions */

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "test.h"
extern int yylex(); // Generated by Flex

void yyerror(char *s);
void printrule(char *s);

/*Bison Declarations*/

quad *qArray[NSYMS]; // Store of Quads
int quadPtr = 0; // Index of next quad
%}
%union { // Placeholder for a value
	int intval;
	symboltable *symp;
}

%token <intval> NUMBER
%token <symp> NAME CHAR ELSE FOR IF INT RET VOID ID CHAR_CONST STR_LIT 
%token PUNC 
%token MULTI_COMM SINGLE_COMM WS
%token EQ_OPT LE_OPT GE_OPT NE_OPT 
%token AND_OPT PTR_OPT OR_OPT
%type <symp> primary_expression postfix_expression multiplicative_expression additive_expression unary_expression


%left '='
%left '|'
%left '^'
%left '&'
%left '+' '-'
%left '*' '/' '%'
%nonassoc UMINUS

//%start translation_unit

%%

list_of_statements: statement
{ printrule("L -> S"); }
;
list_of_statements: list_of_statements statement
{ printrule("L -> L S"); }
;
statement: ID '=' additive_expression ';' //ID = primary_expression
{ 
	qArray[quadPtr++] = new_quad_unary(COPY, $1->name, $3->name);
	printrule("S -> id = E"); 
}
;

primary_expression:
	ID { $$ = $1; printrule("E -> id"); }
	|NUMBER {
	$$ = gentemp();
	char num_s[10];
	sprintf(num_s, "%d", $1);
	qArray[quadPtr++] = new_quad_unary(COPY, $$->name, num_s);
	printrule("E -> num");
	}
	
	|CHAR_CONST { $$ = $1; printrule("E -> Character"); }
	|STR_LIT { $$ = $1; printrule("E -> String"); }
	|'(' primary_expression ')' { $$ = $2; printrule("E -> (E)"); }
;

postfix_expression: 
	primary_expression { $$ = $1; printrule("postfix -> primary"); }
	//|postfix_expression '[' expression ']' { $$ = $2; printrule("E -> [E]"); }
	//|postfix_expression '(' argument_expression_list_opt ')' { $$ = $2; printrule("E -> (E)"); }
;
/*
argument_expression_list_opt: %empty |
	argument_expression_list { $$ = $1; printrule("argument_express_list"); }
;

argument_expression_list:
	assignment_expression { $$ = $1; printrule("unary -> postfix"); }
	|argument_expression_list ',' assignment_expression
;
*/

unary_operator: 
	'&'|'*'|'-'|'!' 
;

unary_expression:
	postfix_expression { $$ = $1; printrule("unary -> postfix"); } 
	|unary_operator unary_expression 
	;

multiplicative_expression:
	unary_expression
	|multiplicative_expression '*' unary_expression 
{
	$$ = gentemp();
	qArray[quadPtr++] = new_quad_binary(MULT, $$->name, $1->name, $3->name);
	printrule("E -> E * E");
}
	|multiplicative_expression '/' unary_expression
{
	$$ = gentemp();
	qArray[quadPtr++] = new_quad_binary(DIV, $$->name, $1->name, $3->name);
	printrule("E -> E / E");
}
	|multiplicative_expression '%' unary_expression
;

additive_expression:
	multiplicative_expression { $$ = $1; printrule("additive -> multiplicative"); }
	|additive_expression '+' multiplicative_expression {
	$$ = gentemp();
	qArray[quadPtr++] = new_quad_binary(PLUS, $$->name, $1->name, $3->name);
	printrule("E -> E + E");
}
	|additive_expression '-' multiplicative_expression {
	$$ = gentemp();
	qArray[quadPtr++] = new_quad_binary(MINUS, $$->name, $1->name, $3->name);
	printrule("E -> E - E");
}
;
/*
relational_expression:
	additive_expression
	| relational_expression '<' additive_expression
	| relational_expression '>' additive_expression
	| relational_expression LE_OPT additive_expression
	| relational_expression GE_OPT additive_expression
;

equality_expression:
	relational_expression
	|equality_expression EQ_OPT relational_expression
	|equality_expression NE_OPT relational_expression
;
	
logical_AND_expression: // Left associative operators
	equality_expression
	|logical_AND_expression AND_OPT equality_expression
;

logical_OR_expression: // Left associative operators
	logical_AND_expression
	|logical_OR_expression OR_OPT logical_AND_expression
;
	
conditional_expression: // Right associative operator
	logical_OR_expression
	|logical_OR_expression '?' expression ':' conditional_expression
;

assignment_expression: // Right associative operator
	conditional_expression
	|unary_expression '=' assignment_expression // unary-expression must have lvalue
;

expression:
	assignment_expression
;
	
declaration: // Simple identifier, 1-D array or function declaration of built-in type
	type_specifier init_declarator ';' // Only one element in a declaration
;

init_declarator:
	declarator//(maybe not sure) Simple identifier, 1-D array or function declaration
	|declarator '=' initializer // Simple id with init. initializer for array / fn/ is semantically skipped
;

type_specifier: // Built-in types
	VOID
	|CHAR
	|INT
;

declarator:
	pointer_opt direct_declarator // Optional injection of pointer
;

direct_declarator:
	ID // Simple identifier
	|ID '[' NUMBER ']' // 1-D array of a built-in type or ptr to it. Only +ve constant
	|ID '(' parameter_list_opt ')'  // Fn. header with params of built-in type or ptr to them
;

pointer:
	'*'
;

pointer_opt: %empty |
pointer
;

parameter_list:
	parameter_declaration
	|parameter_list ',' parameter_declaration
;

parameter_list_opt:
	%empty |
	parameter_list
;

parameter_declaration:
	type_specifier pointer_opt identifier_opt // Only simple ids of a built-in type or ptr to it as params
;

identifier_opt:
	%empty |
	ID
;

initializer:
	assignment_expression
;

//3. Statements
statement:
	compound_statement // Multiple statements and / or nest block/s
	|expression_statement // Any expression or null statements
	|selection_statement // if or if-else
	|iteration_statement // for
	|jump_statement // return
;

compound_statement:
	'{' block_item_list_opt '}'
;

block_item_list_opt:
	%empty |
	block_item_list
;

block_item_list:
	block_item
	|block_item_list block_item
;

block_item: // Block scope - declarations followed by statements
	declaration
	|statement
;

expression_statement:
	expression_opt ';' // do we remove this semi colon?
;

selection_statement:
	IF '(' expression ')' statement
	|IF '(' expression ')' statement ELSE statement
;

expression_opt:
	%empty |
expression
;

iteration_statement:
	FOR '(' expression_opt ';' expression_opt ';' expression_opt ')' statement
;

jump_statement:
	RET expression_opt ';'
;

translation_unit: // Single source file containing main()
	function_definition
	|declaration
;

function_definition:
	type_specifier declarator compound_statement
;

declaration_list:
	declaration
	|declaration_list declaration
;

declaration_list_opt:
	%empty | 
	declaration_list
;
*/

%%

void yyerror(char *s) {
	printf("%s\n", s);
}
void printrule(char *s) {
	FILE *fp = fopen("Trace.txt", "a");
	if (fp) {
		fprintf(fp, "%s\n", s);
	}
	fclose(fp);
}
int main() {
	yyparse();

	for (int i = 0; i < quadPtr; ++i)
		print_quad(qArray[i]);

	return 0;
}
/*Additional C Code*/


