%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int yylex(void);
void yyerror(char *s);
%}

%union {
  int num;
  char *str;
}

%token <num> INTEGER
%token <str> ID
%token IF ELSE

%type <num> expr stmt

%left '-' '+'
%left '*' '/'

%%

program:
  | program stmt '\n'
  | program expr '\n'
  ;

stmt:
  IF '(' expr ')' stmt
  | IF '(' expr ')' stmt ELSE stmt
  | ID '=' expr
  | expr
  ;

expr:
  INTEGER
  | ID
  | expr '+' expr
  | expr '-' expr
  | expr '*' expr
  | expr '/' expr
  | '(' expr ')'
  ;

%%

int main(int argc, char **argv) {
  yyparse();
  return 0;
}

void yyerror(char *s) {
  fprintf(stderr, "error: %s\n", s);
}


--

stmt:
  IF '(' expr ')' stmt
  {
    // Generate three-address code for IF statement
  }
  | IF '(' expr ')' stmt ELSE stmt
  {
    // Generate three-address code for IF-ELSE statement
  }
  | ID '=' expr
  {
    // Generate three-address code for assignment statement
  }
  | expr
  {
    // Generate three-address code for expression
  }
  ;



--


stmt:
  ID '=' expr
  {
    // Generate a new instruction for the assignment
    struct instruction *inst = malloc(sizeof(struct instruction));
    inst->opcode = OP_ASSIGN;
    inst->operand1 = $1; // The ID on the left side of the assignment
    inst->operand2 = $3; // The expression on the right side of the assignment
    inst->result = generate_temp_var(); // Generate a new temporary variable for the result

    // Add the instruction to the list of instructions
    add_instruction(inst);
  }
  ;



---


expr:
  expr '<' expr
  {
    // Generate a new instruction for the '<' operator
    struct instruction *inst = malloc(sizeof(struct instruction));
    inst->opcode = OP_LT;
    inst->operand1 = $1; // The expression on the left side of the '<' operator
    inst->operand2 = $3; // The expression on the right side of the '<' operator
    inst->result = generate_temp_var(); // Generate a new temporary variable for the result

    // Add the instruction to the list of instructions
    add_instruction(inst);
  }
  ;


--

stmt:
  ID '(' params ')' '{' program '}'
  {
    // Generate a new instruction for the function definition
    struct instruction *inst = malloc(sizeof(struct instruction));
    inst->opcode = OP_FUNC;
    inst->operand1 = $1; // The function name
    inst->operand2 = $3; // The function parameters
    inst->result = $6; // The function body (i.e., the program code inside the curly braces)

    // Add the instruction to the list of instructions
    add_instruction(inst);
  }
  ;

--

stmt:
  WHILE '(' expr ')' stmt
  {
    // Generate a new instruction for the start of the loop
    struct instruction *start_inst = malloc(sizeof(struct instruction));
    start_inst->opcode = OP_LABEL;
    start_inst->operand1 = generate_label(); // Generate a new label for the start of the loop
    start_inst->result = NULL;

    // Add the start instruction to the list of instructions
    add_instruction(start_inst);

    // Generate a new instruction for the loop condition
    struct instruction *cond_inst = malloc(sizeof(struct instruction));
    cond_inst->opcode = OP_IF;
    cond_inst->operand1 = $3; // The loop condition
    cond_inst->result = generate_label(); // Generate a new label for the end of the loop

    // Add the condition instruction to the list of instructions
    add_instruction(cond_inst);

    // Generate three-address code for the loop body
    $5;

    // Generate a new instruction for the end of the loop
    struct instruction *end_inst = malloc(sizeof(struct instruction));
    end_inst->opcode = OP_GOTO;
    end_inst->operand1 = start_inst->operand1; // The label for the start of the loop
    end_inst->result = NULL;

    // Add the end instruction to the list of instructions
    add_instruction(end_inst);
  }
  ;
 

 --

 %{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int yylex(void);
void yyerror(char *s);
%}

%union {
  int num;
  char *str;
}

%token <num> INTEGER
%token <str> ID
%token IF ELSE WHILE FOR RETURN
%token <str> TYPE
%token <str> LITERAL

%type <num> expr stmt
%type <str> type

%left '='
%left '||'
%left '&&'
%left '|'
%left '^'
%left '&'
%left '==' '!='
%left '<' '<=' '>' '>='
%left '<<' '>>'
%left '+' '-'
%left '*' '/' '%'

%%

program:
  | program stmt '\n'
  | program type ID '(' params ')' '{' program '}'
  ;

stmt:
  IF '(' expr ')' stmt
  | IF '(' expr ')' stmt ELSE stmt
  | WHILE '(' expr ')' stmt
  | FOR '(' expr ';' expr ';' expr ')' stmt
  | RETURN expr
  | type ID '=' expr
  | expr ';'
  ;

expr:
  INTEGER
  | ID
  | LITERAL
  | '(' expr ')'
  | expr '+' expr
  | expr '-' expr
  | expr '*' expr
  | expr '/' expr
  | expr '%' expr
  | expr '<<' expr
  | expr '>>' expr
  | expr '<' expr
  | expr '<=' expr
  | expr '>' expr
  | expr '>=' expr
  | expr '==' expr
  | expr '!=' expr
  | expr '&' expr
  | expr '^' expr
  | expr '|' expr
  | expr '&&' expr
  | expr '||' expr
  ;

type:
  TYPE
  | TYPE '*'
  ;

params:
  | type ID
  | params ',' type ID
  ;

%%

int main(int argc, char **argv) {
  yyparse();
  return 0;
}

void yyerror(char *s) {
  fprintf(stderr, "error: %s\n", s);
}
 

--

#define SYMBOL_TABLE_SIZE 256

struct symbol {
  char *name;
  int type;
  int value;
  struct symbol *next;
};

struct symbol_table {
  struct symbol *table[SYMBOL_TABLE_SIZE];
};

struct symbol_table *symbol_table_create() {
  struct symbol_table *st = malloc(sizeof(struct symbol_table));
  memset(st->table, 0, sizeof(st->table));
  return st;
}

void symbol_table_destroy(struct symbol_table *st) {
  for (int i = 0; i < SYMBOL_TABLE_SIZE; i++) {
    struct symbol *s = st->table[i];
    while (s != NULL) {
      struct symbol *next = s->next;
      free(s->name);
      free(s);
      s = next;
    }
  }
  free(st);
}

struct symbol *symbol_table_lookup(struct symbol_table *st, char *name) {
  int h = hash(name) % SYMBOL_TABLE_SIZE;
  struct symbol *s = st->table[h];
  while (s != NULL) {
    if (strcmp(s->name, name) == 0) {
      return s;
    }
    s = s->next;
  }
  return NULL;
}

void symbol_table_insert(struct symbol_table *st, char *name, int type, int value) {
  int h = hash(name) % SYMBOL_TABLE_SIZE;
  struct symbol *s = malloc(sizeof(struct symbol));
  s->name = strdup(name);
  s->type = type;
  s->value = value;
  s->next = st->table[h];
  st->table[h] = s;
}


--


stmt:
  ID '=' expr
  {
    // Look up the symbol in the symbol table
    struct symbol *s = symbol_table_lookup(symbol_table, $1);
    if (s == NULL) {
      yyerror("undefined symbol '%s'", $1);
    }

    // Generate a new instruction for the assignment
    struct instruction *inst = malloc(sizeof(struct instruction





