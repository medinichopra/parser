%{ /* C Declarations and Definitions */
#include <string.h>
#include <stdio.h>

extern int yylex(); // Generated by Flex
void yyerror(char *s);
%}


%token CHAR ELSE FOR IF 
%token INT RETURN VOID TYPEDEF
%token IDENTIFIER
%token STRING_LIT
%token C_CONSTANT
%token I_CONSTANT
%token AND_OP
%token PTR_OP
%token OR_OP
%token LE_OP
%token GE_OP
%token EQ_OP
%token NE_OP
%define parse.error detailed

%start translation_unit

%%



constant:
C_CONSTANT |
I_CONSTANT
;

// EXPRESSIONS
primary_expression:
IDENTIFIER | // Simple identifier
constant | // Integer or character constant string-literal this wILLL BE PROBLEM
STRING_LIT |
'(' expression ')'
;

postfix_expression: // Expressions with postfix operators. Left assoc. in C; non-assoc. here 
primary_expression |
postfix_expression '[' expression ']' |// 1-D array access
postfix_expression '(' argument_expression_list_opt ')' |// Function invocation
postfix_expression PTR_OP IDENTIFIER
;

argument_expression_list_opt:
%empty |
argument_expression_list
;

argument_expression_list: 
assignment_expression |
argument_expression_list ',' assignment_expression
;

unary_operator:
'&'|'*' |'+' |'-' |'!';

unary_expression: 
postfix_expression |
unary_operator unary_expression
;

multiplicative_expression: // Left associative operators 
unary_expression |
multiplicative_expression '*' unary_expression |
multiplicative_expression '/' unary_expression |
multiplicative_expression '%' unary_expression
;

additive_expression: // Left associative operators 
multiplicative_expression |
additive_expression '+' multiplicative_expression |
additive_expression '-' multiplicative_expression
;




relational_expression: // Left associative operators 
additive_expression |
relational_expression '<' additive_expression |
relational_expression '>' additive_expression |
relational_expression LE_OP additive_expression |
relational_expression GE_OP additive_expression 
;


equality_expression: // Left associative operators 
relational_expression |
equality_expression EQ_OP relational_expression |
equality_expression NE_OP relational_expression
;

logical_AND_expression: // Left associative operators 
equality_expression |
logical_AND_expression AND_OP equality_expression
;

logical_OR_expression: // Left associative operators 
logical_AND_expression |
logical_OR_expression OR_OP logical_AND_expression
;

conditional_expression: // Right associative operator 
logical_OR_expression |
logical_OR_expression '?' expression ':' conditional_expression
;

assignment_expression: // Right associative operator 
conditional_expression |
unary_expression '=' assignment_expression
;

expression:
assignment_expression
;

//Declarations

declaration: // Simple identifier, 1-D array or function declaration of built-in type 
type_specifier init_declarator ';'
;

init_declarator:
declarator |// Simple identifier, 1-D array or function declaration
declarator '=' initializer
;

type_specifier: // Built-in types 
VOID |
CHAR |
INT
;

declarator:
pointer_opt direct_declarator
;

direct_declarator:
IDENTIFIER | // Simple identifier 
IDENTIFIER '[' I_CONSTANT ']' |
IDENTIFIER '(' parameter_list_opt ')' 
;


pointer: '*';

pointer_opt:
%empty |
pointer
;

parameter_list: 
parameter_declaration|
parameter_list ',' parameter_declaration
;

parameter_list_opt:
%empty |
parameter_list
;


parameter_declaration:
type_specifier pointer_opt identifier_opt
;

identifier_opt:
%empty |
IDENTIFIER
;

initializer:
assignment_expression;
// same as an expression



//initializer: assignment_expression;

// STATEMENT
statement:
compound_statement |// Multiple statements and / or nest block/s
expression_statement |// Any expression or null statements
selection_statement |// if or if_else
iteration_statement |// for
jump_statement
;

compound_statement:
'{' block_item_list_opt '}'
;

block_item_list_opt:
%empty |
block_item_list
;


block_item_list:
block_item |
block_item_list block_item
;

block_item:
declaration |
statement
;

expression_statement:
expressionopt ';'
;

selection_statement:
IF '(' expression ')' statement |
IF '(' expression ')' statement ELSE statement
;

expressionopt:
%empty |
expression
;

// fix this
iteration_statement:
FOR '(' expressionopt ';' expressionopt ';' expressionopt ')' statement 
;

jump_statement:
RETURN expressionopt ';'
;

// idxwond

translation_unit: // Single source file containing main() 
function_definition |
declaration
;

function_definition:
type_specifier declarator '(' declaration_list_opt ')' compound_statement 
;

declaration_list:
declaration |
declaration_list declaration
;

declaration_list_opt:
%empty |
declaration_list
;

%%


void yyerror(char *s) { printf ("error %s\n", s);
}

int main() {
    yyparse(); 
}
